\chapter{{2×3ミキサーを用いた液滴移動の\bout{ない}混合手順の生成}}
\label{proposed}
\section{アルゴリズムの概要}
\ref{proposed}~章では，本論文の提案手法である2$\times$3ミキサーを用いた液滴移動の無いPMD上での混合手順の生成手法の処理の流れを擬似コードを交えて説明する.


まず，本論文の提案手法の入出力について説明する．
本論文の提案手法の入力は，図~\ref{fig:inputoutput}（a）の，2$\times$2ミキサーノードと2$\times$3ミキサーノード，試薬液滴ノードの3種類のノードをで構成されている希釈木である．
また，本論文の提案手法の出力は，図~\ref{fig:inputoutput}（b）から（e）の，入力希釈木に対応したPMD上でのミキサーの混合手順である．
図~\ref{fig:inputoutput}の（b）から（e）において，同じ図内のミキサーは，混合されるタイミング（タイムステップ）が同じミキサー同士である．

希釈木内のあるノードの親ミキサーノード，子ミキサーノード，子試薬液滴ノードに対応した，PMD上に配置されるミキサーや試薬液滴のことを，親ミキサー，子ミキサー，子試薬液滴と呼ぶ．
図~\ref{fig:inputoutput}の（b）から（e）の混合手順において，図~\ref{fig:inputoutput}（a）の希釈木内で子試薬液滴や子ミキサーは，親ミキサーの配置されるセルに提供液滴を残す．
親ミキサーは，それらの提供液滴を移動させずに配置された場所で混合する．

\begin{figure}[tbp]
 \centering\includegraphics[scale=0.41]{img/OutPut.pdf}
 \caption{提案手法の入出力}\label{fig:inputoutput}
\end{figure}

\begin{algorithm}[tbp]
 \caption{提案手法の処理の流れ}\label{alg:all}
 \begin{algorithmic}[1]
     \Require $\mathit{Tree}$：2$\times$2ミキサーノードと2$\times$3ミキサーノード，試薬液滴ノードを含む希釈木 
     \Require $\mathit{PMDSize}$：使用するPMDのサイズ
     \State $\mathit{TransformedTree} \gets$ transform($Tree$) \Comment{希釈木の変形操作}\label{transform_pseudo}
     \State $\mathit{MixInfo \gets}$genMixOrder($\mathit{TransformedTree,PMDSize}$) \Comment{混合手順の生成} \label{xntm_pseudo}

      \Return $\mathit{MixInfo}$
 \end{algorithmic}
\end{algorithm}
Algorithm~\ref{alg:all}に本論文の提案手法のアルゴリズム全体の擬似コードを示した．
本論文の提案手法は大きく分けると，Algorithm~\ref{alg:all}の\ref{transform_pseudo}行目の希釈木の変形操作と，\ref{xntm_pseudo}行目のPMD上での液滴の移動のない混合手順の生成の，2つの処理によって構成されている．

\section{入力希釈木の変形アルゴリズム}
まず，1つ目の処理である，Algorithm~\ref{alg:all}の\ref{transform_pseudo}行目の，希釈木の変形操作の説明を行う． 希釈木の変形操作は，希釈木を入力とし，変形された希釈木を出力する． 変形操作を高さ3の希釈木に対して行った場合の例を図~\ref{fig:Transform}に示した．
図~\ref{fig:Transform}（a）は変形前の希釈木，図~\ref{fig:Transform}（b）は変形後の希釈木である．

希釈木の変形操作では，まず，希釈木内の各ミキサーノードに，自身をルートとする部分木内に含まれるミキサーノードの個数（予測混雑度）を割り当てる．
その後，親ミキサーノードと，その全ての子ミキサーノードとの間に張られているエッジの順番を，各子ミキサーに割り当てられた予測混雑度をキー値にして降順でソートする． 

具体例を用いて，希釈木の変形操作で行われる処理を説明する．
ミキサーノード$N$の予測混雑度の値をECV($N$)，ミキサーノード$N$をルートとする部分木内のミキサーノード数をMixerNum($\mathit{N}$)とする．
図~\ref{fig:Transform}において，ECV(1) = MixerNum(1) = 2，ECV(2) = MixerNum(2) = 2，ECV(3) = MixerNum(3) = 3，ECV(4) = MixerNum(4) = 3である．
ECV(1) = ECV(2) $<$ ECV(3) = ECV(4)であるため，図~\ref{fig:Transform}での希釈木の変形においては，M1，M2をルートとした部分木とM3，M4をルートとした部分木の位置が入れ替えられている．
希釈木の変形操作のアルゴリズムの擬似コードは，Algorithm~\ref{alg:transform}に示す．




\begin{algorithm}[tbp]
 \caption{希釈木の変形操作}\label{alg:transform}
 \begin{algorithmic}[1]
     \Require $\mathit{Tree}$：2$\times$2ミキサーノードと2$\times$3ミキサーノード，試薬液滴ノードを含む希釈木 

     \Function {TransformTree}{$\mathit{Tree.root}$}
        \State $\mathit{Children}$ = array()
        \ForAll {$\mathit{child}\gets \mathit{Tree.root.Children}$}
            \State $\mathit{ecv}=0$
            \If{$\mathit{child.isMixerNode}==\True$}
                \State $\mathit{ecv}+=$MixerNum($child$) \Comment{$\mathit{child}$を根に持つ部分木内のミキサーノード数}
            \EndIf 
            \State Children.append(($\mathit{ecv,child}$))
        \EndFor 
        \State $\mathit{SortedByECV} \gets $sorted($Children,reverse=$\True)\Comment{$\mathit{ecv}$をキー値に降順でソート}
        \State $\mathit{res}\gets$array()
        \ForAll {$\mathit{ecv,child}\gets \mathit{SortedByECV}$}
            \State $\mathit{SubTree}\gets $\Call {TransformTree}{$\mathit{child}$}
            \State $\mathit{res}$.append($\mathit{SubTree}$)
        \EndFor 
        \State $\mathit{root.Children}\gets \mathit{res}$ 

        \Return $\mathit{RootNode}$
    \EndFunction 

 \end{algorithmic}
\end{algorithm}
%次に，この変形操作の目的を説明する．

希釈木の変形操作とともに，本論文の提案手法における中心的な処理である，PMD上での液滴の移動のない混合手順の生成では，親ミキサーの配置セルの一部が重なるよう，子ミキサーや子試薬液滴がPMD上に配置される．
この子ミキサーや子試薬液滴をPMD上へ配置する際に，その配置先のセルにはすでに試薬液滴やミキサー，中間液滴が配置されていることがある．この状態のことをオーバーラップと呼ぶ．
オーバーラップが発生した場合，配置しようとしていたミキサーや試薬液滴のPMD上への配置を先延ばししたり，以降のタイムステップでの混合に使われないPMD上の中間液滴を水で洗い流して，他の子ミキサーや子試薬液滴を配置するためのセルを空ける操作（フラッシング）が必要になる．
フラッシングの回数が増えるほど，試薬合成で必要になる試薬量は増える．

予測混雑度の定義からも分かる通り，高い予測混雑度を持つミキサーノードは子孫ノードを多く持つ．
したがって，高い予測混雑度を持つミキサーノードをルートとする部分木内のミキサーノードは，PMD上での配置先の近くのセルに，多くのミキサーや試薬液滴が配置されることになるため，オーバーラップを発生させやすい．
また，2$\times$2ミキサーノードは最大4個の子ノードを持つのに対して，2$\times$3ミキサーノードは最大6個の子ノードを持つ．
したがって，2$\times$3ミキサーノードは，2$\times$2ミキサーノードよりも，高い予測混雑度を持ちやすく，オーバーラップを発生させやすい．

希釈木の変形操作は，PMD上でのオーバーラップの発生回数を減らすために行われる．
混合手順の生成処理では，希釈木のルートのミキサーノードからBFS順で，各ノードに対応したミキサーや試薬液滴のPMD上での配置先を決めていく．
予測混雑度をキー値にした降順でのソートを行えば，予測混雑度が高いミキサーノードほど，BFS順において早くPMD上での配置先の決定を行うようにすることができる.
この仕組みにより，予測混雑度の高いミキサーノードほど，PMD上で空いたセルが多く，配置方法の自由度が高い，小さいタイムステップでの配置が行える．
これにより，オーバーラップを起こしやすい配置優先度の高い部分木内のミキサーも，PMD上で空いたセルが多い，小さいタイムステップでの配置が行えるようになり，オーバーラップが起こりにくくなる．
オーバーラップが起こりにくくなれば，フラッシングの回数も減らすことができる．

\begin{figure}[tbp]
 \centering\includegraphics[scale=0.5]{img/Transform.pdf}
 \caption{希釈木の変形操作}\label{fig:Transform}
\end{figure}


\section{\mout{PMD上での液滴移動のない混合手順の生成アルゴリズム}}
次に，2つ目の処理である，Algorithm~\ref{alg:all}の\ref{xntm_pseudo}行目の，PMD上での液滴移動のない混合手順の生成の説明を行う．
図~\ref{fig:Transform}（b）の希釈木と，使用するPMDのサイズを入力とし，図~\ref{fig:result}（a）から（e）のPMD上での液滴移動のない混合手順を出力する．
図~\ref{fig:result}（a）から（e）のPMDの各セルに配置された，d$n$はミキサーM$n$によって生成された混合液滴（d3ならば，M3によって生成された混合液滴），R$n$は$n$番目の試薬液滴を表す．
図~\ref{fig:result}（a）から（e）の左下に書かれたTという値は混合手順が実行されるタイムステップ，Fという値はそのタイムステップに至るまでに行われたフラッシングの回数を表す．

\begin{figure}[tbp]
 \centering\includegraphics[scale=0.5]{img/result.pdf}
    \caption{図~\ref{fig:Transform}（b）の希釈木に対するPMD上での液滴移動のない混合手順の生成結果}\label{fig:result}
\end{figure}

Algorithum~\ref{alg:genMixOrder}に液滴移動のないPMD上での混合手順の生成アルゴリズムの擬似コードを示した．
\begin{algorithm}[tbp]
 \caption{液滴移動のないPMD上での混合手順の生成アルゴリズムの擬似コード}\label{alg:genMixOrder}
 \begin{algorithmic}[1]
     \Require $\mathit{Tree}$：2$\times$2ミキサーノードと2$\times$3ミキサーノード，試薬液滴ノードを含む希釈木 
     \Require $\mathit{PMDSize}$：使用するPMDのサイズ
     \State $\mathit{TransformedTree} \gets$\Call{TransformTree}{$\mathit{Tree.RootMixer}$} \Comment{希釈木の変形} 
     \State $\mathit{PMD}\,\gets $  PMDInit($\mathit{PMDSize}$)
     \State $\mathit{PMD}\,\gets $  PlaceOnPMD($\mathit{TransformedTree.RootMixer,PMD}$)
     \State $\mathit{ret} \gets $array() \Comment{混合手順を記録するための配列}

    \State \While{$TransformedTree.RootMixer.state \neq Mixed $ }
        \ForAll{$\mathit{mixer} \gets \mathit{PMD.MixerOnPMD}$} 
        \State $\mathit{AllChildrenPlaced}\gets\mathit{True}$
        \State $\mathit{AllChildrenMixerMixed}\gets\mathit{True}$
        \State $\mathit{ShouldFlush}\gets\mathit{True}$
        \ForAll{$\mathit{child} \gets \mathit{mixer.Children}$} 
            \If {$\mathit{child}\:\mathit{\mathbf{not}}\,\mathit{\mathbf{in}}\:\mathit{PMD.OnPMD}\:and\:$CanPlace($\mathit{child,PMD}$)}
                \State$\mathit{AllChildrenPlaced \gets False}$
                \State $\mathit{PMD}\, \gets$  PlaceOnPMD($\mathit{child,PMD}$) \Comment{子ミキサー，子試薬液滴の配置}
                \State $\mathit{ShouldFlush}\gets\mathit{False}$
            \EndIf 
            \If {$\mathit{child.kind}==\mathit{Mixer} \: \mathit{\mathbf{and}}\: \mathit{child.state}\neq\mathit{Mixed}$}
                \State $\mathit{AllChildrenMixerMixed}\gets\mathit{False}$
            \EndIf 
        \EndFor 
         \If{$\mathit{AllChildrenPlaced}\,\mathit{\mathbf{and}}\, \mathit{AllChildrenMixerMixed}$}
            \State$\mathit{PMD}\gets$Mix($\mathit{mixer,PMD}$)\Comment{ミキサーの混合}
            \State$\mathit{mixer.state} \gets \mathit{Mixed}$ 
            \State$\mathit{ret} $.append($\mathit{mixer}$) 
            \State $\mathit{ShouldFlush}\gets\mathit{False}$
        \EndIf
        \EndFor 
\If{$\mathit{TimeForFlushing}$}
                    \State $\mathit{PMD}\gets$Flush($\mathit{PMD}$)\Comment{フラッシング}
                \EndIf
    \EndWhile 

     \Return $\mathit{ret}$
 \end{algorithmic}
\end{algorithm}

\newpage
PMD上での液滴移動のない混合手順の生成過程で行われる処理は，主に以下の3つである．
\begin{itembox}[l]{混合手順を生成する過程で行われる処理}
\begin{enumerate}
    \item 配置（PMD上に配置されているミキサーの，子ミキサーや子試薬液滴のPMD上への配置）\label{place}
    \item 混合（PMD上に配置されているミキサーでの，液滴の混合）\label{mix}
    \item フラッシング（フラッシングによる，PMD上の空いたセルの確保）\label{flush}
    %\item 延期された配置（手順~\ref{place}で配置できなかったミキサーや子試薬液滴のPMD上への配置）\label{skipped}
\end{enumerate}
\end{itembox}

混合手順の生成アルゴリズムにおいて，基本となる処理は処理~\ref{place}（配置）と処理~\ref{mix}（混合）である．
混合手順の生成アルゴリズムは，処理~\ref{place}（配置）と処理~\ref{mix}（混合）を繰り返す．
処理~\ref{place}（配置）と処理~\ref{mix}（混合）が行えなくなったら，処理~\ref{flush}（フラッシング）を行う．
その後，再び処理~\ref{place}（配置）と処理~\ref{mix}（混合）を行う．
これらの処理の繰り返しを，ルートのミキサーノードであるM0の混合が行われるまで続ける．

\newpage

図~\ref{fig:process}は，図~\ref{fig:Transform}（b）の希釈木を入力として，7$\times$7サイズのPMD上で図~\ref{fig:result}の液滴移動のない混合手順を生成する過程を表している．
混合手順の生成は，図~\ref{fig:process}（a）のようにPMD中央部にルートのミキサー（M0）を配置して開始される（処理~\ref{place})．
その後，図~\ref{fig:process}（b），（c）のように，子ミキサーや子試薬液滴が親ミキサーと一部のセルを共有するように，PMD上に配置される（処理~\ref{place})．
この際，オーバラップしている子ミキサーや子試薬液滴は配置を先延ばしする． 配置を先延ばししたミキサーや試薬液滴以外の全てのミキサーや試薬液滴を配置し終えると，図~\ref{fig:process}（d）のように，ミキサーの混合を行う（処理~\ref{mix}） ．
処理~\ref{place}，処理~\ref{mix}がもうそれ以上行えなくなれば，図~\ref{fig:process}（e）のように，処理~\ref{flush}のフラッシングと配置を先延ばしされていた試薬液滴やミキサーの配置（M1，M8，M10）を行う（処理~\ref{place})．
図~\ref{fig:process}（f）では，M6上に子ミキサーのM2を，M10に子試薬（R1，R2，R3，R4）を配置する（処理~\ref{place})．
図~\ref{fig:process}（g）では，M6，M7，M8，M9，図~\ref{fig:process}（h）では，M4でミキサーでの液滴の混合を行っている（処理~\ref{mix})．
その後，図~\ref{fig:process}（i）でフラッシング（処理~\ref{flush})をした後に，図~\ref{fig:process}（j）では配置を先延ばししていた試薬液滴のM2，M3上への配置と，M2，M3での液滴の混合を行っている（処理~\ref{place})．
図~\ref{fig:process}（k）では，ルートミキサーであるM0での液滴の混合（処理~\ref{mix}） を行うことができ，試薬合成に成功した．

ミキサーでの試薬の混合を行っている，図~\ref{fig:process}（d），（g），（h），（j），（k）が，本論文の提案手法の出力，2$\times$3ミキサーを用いたPMD上での液滴移動のない混合手順である．
\begin{figure}[tbp]
 \centering\includegraphics[scale=0.9]{img/process.pdf}
 \caption{液滴移動のない混合手順の生成過程}\label{fig:process}
\end{figure}


%\section{ライブラリを用いたモジュールの配置{アルゴリズム}}

%ライブラリを用いたモジュールの配置方法を例，図や擬似コードを用いながら説明する．


%希釈木の変形操作の手順や目的などを例や擬似コードを用いながら説明する．

